# Relatório de Estudos

**Nome do Estagiário:** Gustavo Monteiro Gomes Pires  
**Data:** 14/08/2024

**Módulos/Etapas Feitas:**  
1. **Mensageria**
2. **Virtualização**
3. **Computação em nuvem**

## Resumo dos módulos 

**Pub/Sub ou  Mensageria** é um pattern arquetetural extremamente flexível e escalonável, com comunicação desacoplada e assíncrona, ou seja, comunicação independente sem necessidade de um conhecimento direto sobre o estado ou a disponibilidade dos *publishers* e *subscribers*, utilizado em sistemas de mensageria, monitoramento, sistema de notificações entre outros modelos.

- O *Publisher*, por exemplo a *Waze*, publica uma mensagem de acidente em uma rodovia, o *Message Broker* gerencia as mensagens e certifica que seja entregue ao usuário correto, exemplificando, seria alguém próximo ao acidente ou que esteja se direcionando a essa rodovia(Tópico), o *Subscriber* recebe essa mensagem no seu aplicativo.

**Google Cloud Pub/Sub** tem como principais características a escabilidade automática (ajustando o número de mensagens ao número de assinantes), Modelo Pub/Sub onde produtores de mensagens enviam para tópicos e os consumidores(assinantes) recebem, segurança com a integração do Identity and Access Management (IAM) que permite definir quanto os usuários podem acessar e editar.

### **Virtualização**

**Máquinas virtuais (VMs)** são emulações de computadores isoladas em um ambiente de software, ou seja, permite executar vários sistemas operacionais e aplicativos em apenas uma máquina física (hardware), compartilhando recursos físicos como CPU e memória. A portabilidade das VMs facilita a movimentação entre servidores, suportando a escalabilidade e recuperação de desastres. O gerenciamento é simplificado e centralizado por hypervisors, que criam e gerenciam as VMs, podendo ser do tipo bare-metal(executa diretamente no hardware do servidor) ou hosted(executa sobre um sistema operacional host). VMs são amplamente utilizadas para consolidar servidores, criar ambientes de desenvolvimento e teste isolados, executar sistemas legados(antigo) em um ambiente moderno e escalar aplicações na nuvem, trazendo eficiência, flexibilidade e segurança aos recursos de TI.

**Introdução ao Docker**

"**Docker** *é uma plataforma de software que facilita a criação, distribuição e execução de aplicativos dentro de containers. Os containers são ambientes isolados que contêm tudo o que um aplicativo precisa para funcionar, incluindo o código, as bibliotecas e as dependências, garantindo que ele funcione de maneira consistente em diferentes ambientes.*"

Containers Docker são muito utilizados em desenvolvimento e testes pois são ambientes isolados, rápidos e consistentes, ou seja, permite executar múltiplos containers ao mesmo tempo, de maneira rápida porque compartilham o mesmo kernel do computador e são consistentes porque se comportam da mesma maneira em qualquer ambiente/máquina pois utilizam a mesma Imagem Docker, que contêm o mesmo código-fonte, bibliotecas e outras dependências. O Dockerfile é um script com as intruções para a criação da Imagem Docker, DockerHub é um registro público de imagens onde você pode compartilhar ou usar outras imagens, já o Docker Compose gerencia múltiplos containers (Que é o principal desafio ao utilizar o Docker), usando um arquivo YAML para definir serviços, redes e volumes necessários para rodar uma aplicação que utiliza vários containers.

## Links de Laboratórios (se houver)

- [Google Colab 1/Notion 1](URL_do_Lab_1)
- [Google Colab 2/Notion 2](URL_do_Lab_2)
- ...

**Recursos Utilizados:**  
- Projeto 1: Mensageria Waze
```
**PubSub.ts**

interface Subscriber {
  (message: any): void;
}

class PubSub {
  private topics: { [key: string]: Subscriber[] } = {};

  subscribe(topic: string, subscriber: Subscriber): void {
    if (!this.topics[topic]) {
      this.topics[topic] = [];
    }
    this.topics[topic].push(subscriber);
  }

  unsubscribe(topic: string, subscriber: Subscriber): void {
    if (!this.topics[topic]) return;
    this.topics[topic] = this.topics[topic].filter((sub) => sub != subscriber);
  }

  publish(topic: string, message: any): void {
    if (!this.topics[topic]) return;
    this.topics[topic].forEach((subscriber) => subscriber(message));
  }
}

export default PubSub;
```

```
**Simulação Waze**

import PubSub from "./PubSub.ts";

// Definindo a interface TrafficEvent
interface TrafficEvent {
  type: string;
  location: string;
  details: string;
}

// Definindo a interface para os usuários
interface User {
  id: number;
  name: string;
  notify(event: TrafficEvent): void;
}

// Classe que implementa a interface User
class BasicUser implements User {
  id: number;
  name: string;

  constructor(id: number, name: string) {
    this.id = id;
    this.name = name;
  }

  notify(event: TrafficEvent): void {
    console.log(
      `Notificação ${this.name}: ${event.type} em ${event.location} - ${event.details}`
    );
  }
}

// Instanciando o sistema PubSub
const pubSub = new PubSub();

// Função que representa um usuário que reporta um evento de trânsito
function reportTrafficEvent(event: TrafficEvent) {
  console.log("*".repeat(50));
  console.log(
    `Evento Reportado: ${event.type} em ${event.location} - ${event.details}`
  );
  console.log("*".repeat(50));
  pubSub.publish(event.location, event);
}

// Criando instâncias de usuários
const user1 = new BasicUser(1, "Usuário 1");
const user2 = new BasicUser(2, "Usuário 2");
const user3 = new BasicUser(3, "Usuário 3");
const user4 = new BasicUser(4, "Usuário 4");

// Armazenando as funções ligadas
const boundUser1Notify = user1.notify.bind(user1);
const boundUser2Notify = user2.notify.bind(user2);
const boundUser3Notify = user3.notify.bind(user3);
const boundUser4Notify = user4.notify.bind(user4);

// Inscrevendo os usuários para receber notificações de eventos em diferentes localizações
pubSub.subscribe("Centro", boundUser1Notify);
pubSub.subscribe("Centro", boundUser2Notify);
pubSub.subscribe("Centro", boundUser3Notify);
pubSub.subscribe("Centro", boundUser4Notify);

pubSub.subscribe("Rodovia", boundUser1Notify);
pubSub.subscribe("Rodovia", boundUser3Notify);

pubSub.subscribe("Subúrbio", boundUser1Notify);
pubSub.subscribe("Subúrbio", boundUser4Notify);

// Simulando a publicação de eventos de trânsito
reportTrafficEvent({
  type: "Acidente",
  location: "Centro",
  details: "Dois carros envolvidos, trânsito pesado.",
});
reportTrafficEvent({
  type: "Bloqueio de Estrada",
  location: "Rodovia",
  details: "Estrada fechada devido à construção.",
});
reportTrafficEvent({
  type: "Enchente",
  location: "Subúrbio",
  details: "Chuva forte causando alagamentos nas ruas.",
});

// Usuários cancelam a inscrição de eventos no Centro
pubSub.unsubscribe("Centro", boundUser1Notify);
pubSub.unsubscribe("Centro", boundUser2Notify);
pubSub.unsubscribe("Centro", boundUser4Notify);

// Novo evento no Centro
reportTrafficEvent({
  type: "Blitz Policial",
  location: "Centro",
  details: "Blitz policial, trânsito lento.",
});
```
- [Recurso 2]
- [Recurso 3]
- ...

**Principais comandos: (se aplicável)**  
- [Comando 1]
- [Comando 2]
- [Comando 3]
- ...

**Desafios Encontrados:**  
Descreva quaisquer desafios ou obstáculos que você encontrou durante a trilha de aprendizagem e como você os superou ou planeja superá-los.

**Feedback e Ajustes:**  
Descreva qualquer feedback que você recebeu e como você ajustou sua abordagem de estudo com base nesse feedback.

**Próximos Passos:**  
Descreva os próximos passos em sua trilha de aprendizagem. Quais são as próximas etapas ou módulos que você irá abordar?