# üìñ Relat√≥rio de Estudos

**Nome do Estagi√°rio:** Gustavo Monteiro Gomes Pires  
**Data:** 14/08/2024

**M√≥dulos/Etapas Feitas:**  
1. **Mensageria**
2. **Virtualiza√ß√£o**
3. **Computa√ß√£o em nuvem**
4. **CI/CD**
5. **Linux/Shell**
6. **An√°lise de Dados**

## üìë Resumo dos m√≥dulos

### üì¨ Mensageria 

**Pub/Sub** √© um pattern arquetetural extremamente flex√≠vel e escalon√°vel, com comunica√ß√£o desacoplada e ass√≠ncrona, ou seja, comunica√ß√£o independente sem necessidade de um conhecimento direto sobre o estado ou a disponibilidade dos dispositivos *publishers* e *subscribers*, utilizado em sistemas de mensageria, monitoramento, sistema de notifica√ß√µes entre outros modelos.

- O *Publisher*, por exemplo a *Waze*, publica uma mensagem de acidente em uma rodovia, o *Message Broker* gerencia as mensagens e certifica que seja entregue ao usu√°rio correto, exemplificando, seria algu√©m pr√≥ximo ao acidente ou que esteja se direcionando a essa rodovia (T√≥pico), o *Subscriber* recebe essa mensagem no seu aplicativo.

**Google Cloud Pub/Sub** tem como principais caracter√≠sticas a escabilidade autom√°tica (ajustando o n√∫mero de mensagens ao n√∫mero de assinantes), Modelo Pub/Sub onde produtores de mensagens enviam para t√≥picos e os consumidores (assinantes) recebem, seguran√ßa com a integra√ß√£o do Identity and Access Management (IAM) que permite definir quanto os usu√°rios podem acessar e editar o sistema.

### üíª Virtualiza√ß√£o

**M√°quinas virtuais (VMs)** s√£o emula√ß√µes de computadores isoladas em um ambiente de software, ou seja, permite executar v√°rios sistemas operacionais e aplicativos em apenas uma m√°quina f√≠sica (hardware), compartilhando recursos f√≠sicos como CPU e mem√≥ria. A portabilidade das VMs facilita a movimenta√ß√£o entre servidores, suportando a escalabilidade e recupera√ß√£o de desastres. O gerenciamento √© simplificado e centralizado por hypervisors, que criam e gerenciam as VMs, podendo ser do tipo bare-metal(executa diretamente no hardware do servidor) ou hosted(executa sobre um sistema operacional host). VMs s√£o amplamente utilizadas para consolidar servidores, criar ambientes de desenvolvimento e teste isolados, executar sistemas legados(antigo) em um ambiente moderno e escalar aplica√ß√µes na nuvem, trazendo efici√™ncia, flexibilidade e seguran√ßa aos recursos de TI.

```mermaid
graph TD
subgraph Funcionamento Virtual Machine's
    PhysicalServer(Servidor F√≠sico) --> |Recursos: CPU, Mem√≥ria, Armazenamento| Hypervisor(Hypervisor)
    
    Hypervisor --> BareMetal(Bare-metal)
    Hypervisor --> Hosted(Hosted)
    Hosted(Hosted) --> SistemaOperacional(Sistema Operacional)

    BareMetal --> VM2[VM 3]
    BareMetal --> VM3[VM 4]
    
    SistemaOperacional --> VM4[VM 1]
    SistemaOperacional --> VM5[VM 2]
end
```

**Docker** üê≥

"*√â uma plataforma de software que facilita a cria√ß√£o, distribui√ß√£o e execu√ß√£o de aplicativos dentro de containers. Os containers s√£o ambientes isolados que cont√™m tudo o que um aplicativo precisa para funcionar, incluindo o c√≥digo, as bibliotecas e as depend√™ncias, garantindo que ele funcione de maneira consistente em diferentes ambientes.*"

Containers Docker s√£o muito utilizados em desenvolvimento e testes pois s√£o ambientes isolados, r√°pidos e consistentes, ou seja, permite executar m√∫ltiplos containers ao mesmo tempo, de maneira r√°pida porque compartilham o mesmo kernel do computador e s√£o consistentes porque se comportam da mesma maneira em qualquer ambiente/m√°quina pois utilizam a mesma Imagem Docker, que cont√™m o mesmo c√≥digo-fonte, bibliotecas e outras depend√™ncias. O Dockerfile √© um script com as intru√ß√µes para a cria√ß√£o da Imagem Docker, DockerHub √© um registro p√∫blico de imagens onde voc√™ pode compartilhar ou usar outras imagens, j√° o Docker Compose gerencia m√∫ltiplos containers (Que √© o principal desafio ao utilizar o Docker), usando um arquivo YAML para definir servi√ßos, redes e volumes necess√°rios para rodar uma aplica√ß√£o que utiliza v√°rios containers.

```mermaid
graph TD
  subgraph Funcionamento Docker
    Docker(Docker) --> |Cria e Executa| Containers[Containers Docker]
    
    Docker --> |Constr√≥i| Dockerfile[Dockerfile]
    Dockerfile --> |Gera| ImagemDocker[Imagem Docker]
    
    ImagemDocker --> |Armazena| DockerHub[Docker Hub]
    DockerHub --> |Compartilha Imagens| Containers
    
    DockerCompose[Docker Compose] --> |Gerencia M√∫ltiplos Containers| Containers
    DockerCompose --> |Define em YAML| Servi√ßos[Servi√ßos, Redes, Volumes]
  end
```

**Kubernetes** üéì

Plataforma de c√≥digo aberto para orquestra√ß√£o de containers, automatizando o dimensionamento, tanto horizontalmente (adicionando mais inst√¢ncias de containers) quanto verticalmente (ajustando os recursos alocados para os containers) e gerenciamento, incluindo a implanta√ß√£o, a atualiza√ß√£o, o balanceamento de carga e a recupera√ß√£o de falhas.

```mermaid
graph TB
    subgraph Cluster
        direction TB
        
        MasterNode(Master Node)
        
        Node1(Node 1)
            Pod1(Pod 1)
            Pod2(Pod 2)

        Node2(Node 2)
            Pod3(Pod 3)
            Pod4(Pod 4)
    end
    
    MasterNode --> Node1
    MasterNode --> Node2
    Node1 --> Pod1
    Node1 --> Pod2
    Node2 --> Pod3
    Node2 --> Pod4
```

O diagrama acima mostra o exemplo de um cluster. O Master Node coordena o cluster, gerenciando a comunica√ß√£o e controlando a execu√ß√£o dos Nodes, esses que controlam os Pods. Cada Pod √© a menor unidade de implanta√ß√£o e pode conter um ou mais containers que compartilham armazenamento e rede. O Master Node garante que os Nodes e Pods sejam executados de acordo com as defini√ß√µes de Deployment. Dentro do cluster, o ***Service*** √© respons√°vel por expor os Pods como servi√ßos de rede, permitindo a comunica√ß√£o entre eles e com o mundo externo. O ***ConfigMap*** e o ***Secret*** s√£o utilizados para gerenciar configura√ß√µes e informa√ß√µes sens√≠veis, separando-as do c√≥digo dos containers, o que facilita o gerenciamento e melhora a seguran√ßa. O ***Ingress*** gerencia o acesso externo aos servi√ßos, fornecendo balanceamento de carga e roteamento de tr√°fego com base em regras de URL e host.

### ‚òÅÔ∏è Computa√ß√£o em Nuvem

***Servi√ßos Google Cloud***

- Execu√ß√£o de pipelines

**Dataflow** realiza processamento e an√°lise de dados em larga escala, baseado no modelo de programa√ß√£o do Apache Beam. Permite criar e executar **pipelines** de processamento de dados em tempo real e em batch (pacotes) com alta efici√™ncia e escalabilidade, sem necessidade de configura√ß√£o manual. O Dataflow oferece gerenciamento autom√°tico de recursos, integra√ß√£o com outras ferramentas do Google Cloud, e ferramentas para visualiza√ß√£o e monitoramento de **pipelines**. Seus casos de uso incluem processamento de dados em tempo real, ETL, an√°lise de dados em batch e integra√ß√£o de dados. Os principais benef√≠cios s√£o a escalabilidade autom√°tica, flexibilidade no processamento e f√°cil integra√ß√£o com o ecossistema Google Cloud.

- Gerenciamento de clusters

**Dataproc** facilita o processamento de dados em larga escala utilizando Apache Hadoop e Apache Spark. Simplifica o gerenciamento de **clusters**, oferecendo cria√ß√£o, configura√ß√£o e escalabilidade autom√°tica, al√©m de integra√ß√£o com outras ferramentas do Google Cloud como *BigQuery* e *Cloud Storage*. O Dataproc permite a escalabilidade din√¢mica dos **clusters**, √© eficiente em termos de custo, com suporte a frameworks populares para criar *jobs*(Tarefas enviadas para os clusters) e ferramentas de monitoramento. Ideal para grandes volumes de dados, an√°lises complexas e machine learning, tamb√©m proporciona flexibilidade e otimiza√ß√£o de custos, embora o uso de frameworks e o gerenciamento de grandes volumes de dados possam apresentar dificuldades.

- Orquestra√ß√£o de workflows

**Composer** √© um servi√ßo gerenciado de orquestra√ß√£o de **workflows** baseado no Apache Airflow, que facilita a cria√ß√£o, execu√ß√£o e monitoramento de pipelines de dados e **workflows** complexos de maneira escal√°vel e eficiente. Com integra√ß√£o aos servi√ßos do Google Cloud, como *BigQuery* e *Cloud Storage*, o Composer automatiza o gerenciamento de recursos, oferece uma interface gr√°fica para visualiza√ß√£o e monitoramento, e suporta pr√°ticas de seguran√ßa e compliance, mas pode apresentar desafios, como a complexidade de configura√ß√£o e dificuldade de aprendizagem, al√©m de custos que podem aumentar com a complexidade dos **workflows**.

- Resposta/Suporte em tempo real

**Functions** permite a execu√ß√£o de c√≥digo em resposta a eventos sem a necessidade de gerenciar servidores. Oferece escalabilidade autom√°tica e econ√¥mica, respondendo a eventos como mudan√ßas em *Cloud Storage*, mensagens do *Pub/Sub*, e solicita√ß√µes HTTP. Com suporte a v√°rias linguagens de programa√ß√£o e f√°cil integra√ß√£o com outros servi√ßos do Google Cloud, √© ideal para criar APIs, processar arquivos, integrar dados, automatizar processos e responder a eventos em tempo real. O modelo de pre√ßos √© baseado no uso, que pode resultar em economia para aplica√ß√µes com cargas de trabalho bem gerenciadas.

### üîÑ CI/CD

Integra√ß√£o Cont√≠nua/Deploy Cont√≠nuo (CI/CD) s√£o pr√°ticas no desenvolvimento de softwares modernos para garantir qualidade e efici√™ncia no processo. Tem objetivo de automatizar o processo de constru√ß√£o, teste e implanta√ß√£o do produto.

- CI

*"Devs fazem mudan√ßas no c√≥digo constantemente e as enviam para o reposit√≥rio. O sistema de CI detecta as mudan√ßas, executa um build do c√≥digo e realiza testes automatizados. Relat√≥rios s√£o gerados para indicar o sucesso ou falha dos testes, permitindo corre√ß√£o r√°pida de problemas."*

- CD

*"Ap√≥s a integra√ß√£o cont√≠nua, o c√≥digo √© automaticamente implantado em um ambiente de staging(testes). Testes adicionais s√£o executados em staging para garantir que o software esteja pronto para produ√ß√£o. Minimizando riscos e garantindo que o c√≥digo esteja sempre pronto para produ√ß√£o, entregando atualiza√ß√µes para os usu√°rios finais mais rapidamente e frequentemente."*

Essas pr√°ticas reduzem erros no c√≥digo pois sofre testes constantes, entrega r√°pida e frequente ao usu√°rio final, fornece feedback ap√≥s testes garantindo a qualidade do software por√©m garantir as depend√™ncias da pipeline consistentes e seguras pode ser complexo para projetos grandes e com v√°rios ambientes.

### üìÅ Linux/Shell

Shell scripts s√£o arquivos de texto que cont√™m uma s√©rie de comandos que o shell pode interpretar e executar, usados para automatizar tarefas repetitivas e simplificar a execu√ß√£o de comandos complexos no ambiente de linha de comando.

- Script: Arquivo que cont√©m uma sequ√™ncia de comandos que s√£o executados pelo shell. Vari√°veis, loops, condicionais e fun√ß√µes para executar tarefas automatizadas.

- Comandos: Shell scripts consistem em comandos que o shell pode executar, como `ls` para listar arquivos, `grep` para buscar padr√µes, e `cp` para copiar arquivos.

- Vari√°veis: Usadas para armazenar dados que podem ser utilizados em comandos e opera√ß√µes. Definidas com um nome e podem armazenar valores como strings ou n√∫meros.

- Loops e Condicionais: Existem loops (`for`, `while`) e condicionais (`if`, `else`), para executar comandos repetidamente ou tomar decis√µes com base em condi√ß√µes.

- Fun√ß√µes: Encapsulam um conjunto de comandos em um bloco reutiliz√°vel, facilitando a modulariza√ß√£o e a manuten√ß√£o do script.

Exemplos:
- Backup de arquivos:
`tar -czf $BACKUP_DIR/backup-$TIMESTAMP.tar.gz $SOURCE_DIR`

- Automatizar cria√ß√£o de repositorios de projeto:
```
# Definir diretorio raiz e nome
BASE_DIR="/home/user/projects"
PROJECT_NAME="new_project"

# Criar a estrutura do projeto
mkdir -p $BASE_DIR/$PROJECT_NAME/{src,bin,docs}

echo "Estrutura do projeto criada"
```

### üìä An√°lise de dados

Sua defini√ß√£o √© o processo de inspecionar, limpar e modelar os dados com objetivo de extrair informa√ß√µes √∫teis e apoiar tomadas de decis√£o.

- Extra√ß√£o e Modula√ß√£o dos dados

Primeiramente devemos *coletar* os dados, podem ser de diferentes fontes, como dados da empresa, de pesquisas ou at√© mesmo de dispositivos, como sensores ou CLP's. Ap√≥s isso devemos *molda-l√≥s*, eliminando dados ausentes ou duplicados e formatar para utiliza√ß√£o, garantindo que sejam precisos e coesos, *explorar* os dados para definir seus padr√µes e rela√ß√µes, identificar tend√™ncias e anomalias. 

- An√°lises 

Depois disso realizamos **an√°lises**, a *descritiva* fornece uma vis√£o ampla, ajudando a entender as tend√™ncias como desvio padr√£o, m√©dia e mediana. A an√°lise *diagn√≥stica* investiga as causas de uma tend√™ncia ou evento. A *preditiva* utiliza t√©cnicas estat√≠sticas e algoritmos ML para prever futuros resultaddos como eventos futuros ou demanda de produtos. *Prescritiva* √© similar, em vez de prever, recomenda a√ß√µes para tomar decis√µes ou resolver problemas.

- Visualiza√ß√£o e Interpreta√ß√£o

Continuando esse processo podemos melhorar a *visualiza√ß√£o* desses dados com representa√ß√µes gr√°ficas como dashboards, tabelas e mapas(Power BI, Google Data Studio, Execel, etc). Tudo isso a ajuda na *interpreta√ß√£o* e *comunica√ß√£o* desses dados, garantindo que sejam compreendidos e utilizados realmente para previs√µes ou tomar decis√µes.

**‚úèÔ∏è Recursos Utilizados:**  
- Projeto 1: Mensageria Waze (Fonte: C√≥digo Fonte no Youtube)

```
**PubSub.ts**

interface Subscriber {
  (message: any): void;
}

class PubSub {
  private topics: { [key: string]: Subscriber[] } = {};

  subscribe(topic: string, subscriber: Subscriber): void {
    if (!this.topics[topic]) {
      this.topics[topic] = [];
    }
    this.topics[topic].push(subscriber);
  }

  unsubscribe(topic: string, subscriber: Subscriber): void {
    if (!this.topics[topic]) return;
    this.topics[topic] = this.topics[topic].filter((sub) => sub != subscriber);
  }

  publish(topic: string, message: any): void {
    if (!this.topics[topic]) return;
    this.topics[topic].forEach((subscriber) => subscriber(message));
  }
}

export default PubSub;
```

```
**Simula√ß√£oWaze.ts**

import PubSub from "./PubSub.ts";

// Definindo a interface TrafficEvent
interface TrafficEvent {
  type: string;
  location: string;
  details: string;
}

// Definindo a interface para os usu√°rios
interface User {
  id: number;
  name: string;
  notify(event: TrafficEvent): void;
}

// Classe que implementa a interface User
class BasicUser implements User {
  id: number;
  name: string;

  constructor(id: number, name: string) {
    this.id = id;
    this.name = name;
  }

  notify(event: TrafficEvent): void {
    console.log(
      `Notifica√ß√£o ${this.name}: ${event.type} em ${event.location} - ${event.details}`
    );
  }
}

// Instanciando o sistema PubSub
const pubSub = new PubSub();

// Fun√ß√£o que representa um usu√°rio que reporta um evento de tr√¢nsito
function reportTrafficEvent(event: TrafficEvent) {
  console.log("*".repeat(50));
  console.log(
    `Evento Reportado: ${event.type} em ${event.location} - ${event.details}`
  );
  console.log("*".repeat(50));
  pubSub.publish(event.location, event);
}

// Criando inst√¢ncias de usu√°rios
const user1 = new BasicUser(1, "Usu√°rio 1");
const user2 = new BasicUser(2, "Usu√°rio 2");
const user3 = new BasicUser(3, "Usu√°rio 3");
const user4 = new BasicUser(4, "Usu√°rio 4");

// Armazenando as fun√ß√µes ligadas
const boundUser1Notify = user1.notify.bind(user1);
const boundUser2Notify = user2.notify.bind(user2);
const boundUser3Notify = user3.notify.bind(user3);
const boundUser4Notify = user4.notify.bind(user4);

// Inscrevendo os usu√°rios para receber notifica√ß√µes de eventos em diferentes localiza√ß√µes
pubSub.subscribe("Centro", boundUser1Notify);
pubSub.subscribe("Centro", boundUser2Notify);
pubSub.subscribe("Centro", boundUser3Notify);
pubSub.subscribe("Centro", boundUser4Notify);

pubSub.subscribe("Rodovia", boundUser1Notify);
pubSub.subscribe("Rodovia", boundUser3Notify);

pubSub.subscribe("Sub√∫rbio", boundUser1Notify);
pubSub.subscribe("Sub√∫rbio", boundUser4Notify);

// Simulando a publica√ß√£o de eventos de tr√¢nsito
reportTrafficEvent({
  type: "Acidente",
  location: "Centro",
  details: "Dois carros envolvidos, tr√¢nsito pesado.",
});
reportTrafficEvent({
  type: "Bloqueio de Estrada",
  location: "Rodovia",
  details: "Estrada fechada devido √† constru√ß√£o.",
});
reportTrafficEvent({
  type: "Enchente",
  location: "Sub√∫rbio",
  details: "Chuva forte causando alagamentos nas ruas.",
});

// Usu√°rios cancelam a inscri√ß√£o de eventos no Centro
pubSub.unsubscribe("Centro", boundUser1Notify);
pubSub.unsubscribe("Centro", boundUser2Notify);
pubSub.unsubscribe("Centro", boundUser4Notify);

// Novo evento no Centro, ou seja, apenas o User3 vai receber
reportTrafficEvent({
  type: "Blitz Policial",
  location: "Centro",
  details: "Blitz policial, tr√¢nsito lento.",
});
```

**üìå Principais comandos:**  

***Prompt***
- `mkdir [nome da pasta] # Criar diretorio`
- `cd [nome da pasta] # Entra no diretorio`
- `code . # Abre o VS Code`

***Shell***
- `echo "$VARIAVEL ser√° printada no prompt." # Print de resposta ao usuario`
- `mkdir -p $BASE_DIR/$PROJECT_NAME/{src,bin,docs} # Cria uma estrutura de projeto (V√°rios diretorios)`
- `sudo apt upgrade -y # Atualiza todos os pacotes`

**‚ö†Ô∏è Desafios Encontrados:**  

A falta de atividades ou um ambiente mais pr√°tico, assim como alguns termos t√©cnicos, podem ser um empecilho na hora da compreens√£o de certos assuntos, por√©m facilmente resolvido com a ajuda de recursos externos como v√≠deos did√°ticos e pequenos projetos dispon√≠veis no GitHub ou Youtube.

**üìù Feedback e Ajustes:**  

Explicar alguns termos t√©cnicos, a mistura de linguagens pode atrapalhar a compreens√£o de alguns estudantes.

**üèÜPr√≥ximos Passos:**  

Realizar projetos mais elaborados e did√°ticos com finalidade de reduzir a curva de aprendizado com efici√™ncia e consist√™ncia.